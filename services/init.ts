import {
  checkContainerRuntime,
  expandPath,
  log,
  runCommand,
} from "../utils.ts";
import { Config, defaultConfig } from "../config.ts";

const example_hba = `
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust
host    all             all             127.0.0.1/32            trust
host    all             all             172.16.0.0/12           trust
host    all             all             192.168.0.0/16          trust
local   replication     all                                     trust
host    replication     all             127.0.0.1/32            trust
host    replication     all             ::1/128                 trust
host    all             all             0.0.0.0/0               md5
`;

const exmaple_ident = `
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME
zvpg  postgres   postgres
zvpg  root       postgres

# ========== ADD YOUR MAPPINGS HERE ==========
# mygroup myusername mypgusername
`;

const example_conf = `
# CONFIG LOCATIONS: These are auto-generated by ZVPG. **DO NOT** edit manually.
data_directory = '/var/lib/postgresql/data'
hba_file = '/etc/postgresql/pg_hba.conf'
ident_file = '/etc/postgresql/pg_ident.conf'


# CONNECTIONS AND AUTHENTICATION
listen_addresses = '*'
port = 5432
max_connections = 100              # Reasonable default for small deployments


# RESOURCE USAGE
shared_buffers = 128MB             # 25% of available RAM is common for dedicated servers
work_mem = 4MB                     # Default work memory per operation
maintenance_work_mem = 64MB        # For maintenance operations
dynamic_shared_memory_type = posix # Default on most systems

# WRITE-AHEAD LOG
wal_level = replica                # Minimum for point-in-time recovery
synchronous_commit = on            # Ensures durability (off for better performance)
wal_buffers = -1                   # Automatic sizing (usually 1/32 of shared_buffers)

# LOGGING
log_destination = 'stderr'         # Basic logging
logging_collector = on             # Enable log file collection
log_min_duration_statement = 1000  # Log slow queries (>1s)
log_checkpoints = on               # Useful for performance analysis
log_line_prefix = '%m[%p] %q%u@%d '# Prefix
log_timezone = 'Etc/UTC'           # Consistent timezone for logs

# JIT COMPILER
jit = on                           # Enable JIT compilation for performance
jit_provider = 'llvmjit'           # Use LLVM JIT for better performance
jit_above_cost = 100000            # Enable JIT for expensive queries

# ========== ADD YOUR CONFIGS HERE ==========
# cron.database_name = 'postgres'

# ========== ADD YOUR EXTENSIONS HERE ==========
# shared_preload_libraries = 'pg_stat_statements, pgaudit, plpgsql, pg_cron, timescaledb'	# (change requires restart)
`;

export class InitService {
  private config: Config;

  constructor(config: Config) {
    this.config = config;
  }

  /**
   * Initialize the ZFS Verioned PostgreSQL Engine environment
   * @returns Promise<void>
   */
  async initializeEnvironment(): Promise<void> {
    try {
      log.info("Initializing ZFS Verioned PostgreSQL Engine environment...");

      // Check and install system dependencies
      await this.checkSystemDependencies();

      // Setup ZFS pool and datasets
      await this.setupZfsEnvironment();

      // Setup PostgreSQL environment
      await this.setupPostgresEnvironment();

      // Create necessary directories
      await this.createDirectories();

      // Set appropriate permissions
      await this.setPermissions();

      log.success(
        "ZFS Verioned PostgreSQL Engine environment initialized successfully",
      );
    } catch (error) {
      const err = error as Error;
      log.error(`Failed to initialize environment: ${err.message}`);
      throw error;
    }
  }

  /**
   * Check if the environment is properly initialized
   * @returns Promise<{initialized: boolean, issues: string[]}>
   */
  async checkEnvironment(): Promise<
    { initialized: boolean; issues: string[] }
  > {
    const issues: string[] = [];

    try {
      log.info("Checking ZFS Verioned PostgreSQL Engine environment...");

      // Check ZFS pool
      const zfsPoolExists = await this.checkZfsPool();
      if (!zfsPoolExists) {
        issues.push(`ZFS pool '${this.config.zfsPool}' does not exist`);
      }

      // Check container runtime
      const containerRuntimeAvailable = await this.checkContainerRuntime();
      if (!containerRuntimeAvailable) {
        issues.push(
          `Container runtime '${this.config.containerRuntime}' is not installed or not accessible`,
        );
      }

      // Check PostgreSQL config directory
      const pgConfigDirExists = await this.checkPgConfigDirectory();
      if (!pgConfigDirExists) {
        issues.push(
          `PostgreSQL config directory '${this.config.pgConfigDir}' does not exist`,
        );
      }

      // Check mount directory
      const mountDirExists = await this.checkMountDirectory();
      if (!mountDirExists) {
        issues.push(`Mount directory '${this.config.mountDir}' does not exist`);
      }

      // Check permissions
      const permissionsOk = await this.checkPermissions();
      if (!permissionsOk) {
        issues.push("Incorrect permissions on mount directory");
      }

      const initialized = issues.length === 0;

      if (initialized) {
        log.success("Environment check passed");
      } else {
        log.warn(`Environment check found ${issues.length} issues`);
      }

      return { initialized, issues };
    } catch (error) {
      const err = error as Error;
      log.error(`Failed to check environment: ${err.message}`);
      issues.push(`Check failed: ${err.message}`);
      return { initialized: false, issues };
    }
  }

  /**
   * Reset the ZFS Verioned PostgreSQL Engine environment
   * @param force - Force reset even if clones exist
   * @returns Promise<void>
   */
  async resetEnvironment(force: boolean = false): Promise<void> {
    try {
      log.info("Resetting ZFS Verioned PostgreSQL Engine environment...");

      if (!force) {
        // Check for active clones
        const clones = await this.listActiveClones();
        if (clones.length > 0) {
          throw new Error(
            `Cannot reset environment: ${clones.length} active clones found. Use --force to override.`,
          );
        }
      }

      // Destroy ZFS datasets (but not the pool)
      await this.destroyZfsDatasets();

      // Recreate base structure
      await this.setupZfsEnvironment();

      log.success(
        "ZFS Verioned PostgreSQL Engine environment reset successfully",
      );
    } catch (error) {
      const err = error as Error;
      log.error(`Failed to reset environment: ${err.message}`);
      throw error;
    }
  }

  /**
   * Check system dependencies
   * @returns Promise<void>
   */
  private async checkSystemDependencies(): Promise<void> {
    log.info("Checking system dependencies...");

    // Check if running as root or with sudo
    const isRoot = await this.checkRootAccess();
    if (!isRoot) {
      throw new Error("Root access required for initialization");
    }

    // Check ZFS availability
    const zfsAvailable = await this.checkZfsAvailability();
    if (!zfsAvailable) {
      throw new Error("ZFS is not available on this system");
    }

    // Check container runtime availability
    const containerRuntimeAvailable = await this
      .checkContainerRuntimeAvailability();
    if (!containerRuntimeAvailable) {
      throw new Error(
        `Container runtime '${this.config.containerRuntime}' is not available on this system`,
      );
    }

    log.success("System dependencies check passed");
  }

  /**
   * Setup ZFS environment
   * @returns Promise<void>
   */
  private async setupZfsEnvironment(): Promise<void> {
    log.info("Setting up ZFS environment...");

    // Check if ZFS pool exists
    const poolExists = await this.checkZfsPool();
    if (!poolExists) {
      throw new Error(
        `ZFS pool '${this.config.zfsPool}' does not exist. Please create it first.`,
      );
    }

    // Create base dataset if it doesn't exist
    const baseDataset = `${this.config.zfsPool}/zvpg`;
    try {
      await runCommand("zfs", ["create", baseDataset]);
      log.success(`Created base dataset: ${baseDataset}`);
    } catch (_error) {
      // Dataset might already exist
      log.info(`Base dataset ${baseDataset} already exists or creation failed`);
    }

    // Set ZFS properties
    await runCommand("zfs", [
      "set",
      "mountpoint=" + this.config.mountDir,
      baseDataset,
    ]);
    await runCommand("zfs", ["set", "compression=lz4", baseDataset]);
    await runCommand("zfs", ["set", "atime=off", baseDataset]);

    log.success("ZFS environment setup completed");
  }

  /**
   * Setup PostgreSQL environment
   * @returns Promise<void>
   */
  private async setupPostgresEnvironment(): Promise<void> {
    log.info("Setting up PostgreSQL environment...");

    // Create PostgreSQL config directory
    await this.createPgConfigDirectory();
  }

  /**
   * Create necessary directories
   * @returns Promise<void>
   */
  private async createDirectories(): Promise<void> {
    log.info("Creating necessary directories...");

    const directories = [
      this.config.mountDir,
      `${this.config.mountDir}/${this.config.dataSubdir}`,
      `${this.config.mountDir}/${this.config.clonesSubdir}`,
      `${this.config.mountDir}/${this.config.socketSubdir}`,
      this.config.logDir,
    ];

    for (const dir of directories) {
      await runCommand("mkdir", ["-p", dir]);
    }

    log.success("Directories created successfully");
  }

  /**
   * Set appropriate permissions
   * @returns Promise<void>
   */
  private async setPermissions(): Promise<void> {
    log.info("Setting permissions...");

    // Set ownership to postgres user
    await runCommand("chown", [
      "-R",
      `${this.config.postgresUser}:${this.config.postgresUser}`,
      this.config.mountDir,
    ]);

    // Set directory permissions
    await runCommand("chmod", ["755", this.config.mountDir]);
    await runCommand("chmod", [
      "700",
      `${this.config.mountDir}/${this.config.dataSubdir}`,
    ]);

    log.success("Permissions set successfully");
  }

  /**
   * Check if ZFS pool exists
   * @returns Promise<boolean>
   */
  private async checkZfsPool(): Promise<boolean> {
    try {
      await runCommand("zfs", ["list", this.config.zfsPool]);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Check mount directory
   * @returns Promise<boolean>
   */
  private async checkMountDirectory(): Promise<boolean> {
    try {
      await runCommand("ls", ["-d", this.config.mountDir]);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Check permissions
   * @returns Promise<boolean>
   */
  private async checkPermissions(): Promise<boolean> {
    try {
      const result = await runCommand("stat", [
        "-c",
        "%U:%G",
        this.config.mountDir,
      ]);
      const ownership = result.stdout?.trim();
      return ownership ===
        `${this.config.postgresUser}:${this.config.postgresUser}`;
    } catch {
      return false;
    }
  }

  /**
   * Check root access
   * @returns Promise<boolean>
   */
  private async checkRootAccess(): Promise<boolean> {
    try {
      const result = await runCommand("id", ["-u"]);
      return result.stdout?.trim() === "0";
    } catch {
      return false;
    }
  }

  /**
   * Check ZFS availability
   * @returns Promise<boolean>
   */
  private async checkZfsAvailability(): Promise<boolean> {
    try {
      await runCommand("which", ["zfs"]);
      await runCommand("zfs", ["version"]);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * List active clones
   * @returns Promise<string[]>
   */
  private async listActiveClones(): Promise<string[]> {
    try {
      const result = await runCommand("zfs", [
        "list",
        "-r",
        "-t",
        "filesystem",
        "-H",
        "-o",
        "name",
        this.config.zfsPool,
      ]);
      const lines = result.stdout?.trim().split("\n") || [];

      return lines
        .filter((line) => line.trim() && line !== this.config.zfsPool)
        .map((line) => line.replace(`${this.config.zfsPool}/`, ""));
    } catch {
      return [];
    }
  }

  /**
   * Destroy ZFS datasets
   * @returns Promise<void>
   */
  private async destroyZfsDatasets(): Promise<void> {
    log.info("Destroying ZFS datasets...");

    try {
      const baseDataset = `${this.config.zfsPool}/zvpg`;
      await runCommand("zfs", ["destroy", "-r", baseDataset]);
      log.success("ZFS datasets destroyed");
    } catch (_error) {
      log.warn("Failed to destroy ZFS datasets - they may not exist");
    }
  }

  /**
   * Check container runtime availability
   * @returns Promise<boolean>
   */
  private async checkContainerRuntimeAvailability(): Promise<boolean> {
    return await checkContainerRuntime(this.config.containerRuntime);
  }

  /**
   * Check if container runtime is available
   * @returns Promise<boolean>
   */
  private async checkContainerRuntime(): Promise<boolean> {
    return await checkContainerRuntime(this.config.containerRuntime);
  }

  /**
   * Check PostgreSQL config directory
   * @returns Promise<boolean>
   */
  private async checkPgConfigDirectory(): Promise<boolean> {
    try {
      const configDir = expandPath(this.config.pgConfigDir);
      await runCommand("ls", ["-d", configDir]);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Create PostgreSQL config directory
   * @returns Promise<void>
   */
  private async createPgConfigDirectory(): Promise<void> {
    const configDir = expandPath(this.config.pgConfigDir);

    try {
      await runCommand("mkdir", ["-p", configDir]);
      log.info(`Created PostgreSQL config directory: ${configDir}`);
      // write example files
      await Deno.writeTextFile(`${configDir}/pg_hba.conf`, example_hba.trim());
      await Deno.writeTextFile(
        `${configDir}/pg_ident.conf`,
        exmaple_ident.trim(),
      );
      await Deno.writeTextFile(
        `${configDir}/postgresql.conf`,
        example_conf.trim(),
      );
      // example config.json
      await Deno.writeTextFile(
        `${configDir}/config.json`,
        JSON.stringify(defaultConfig, null, 2),
      );
      log.success("PostgreSQL config directory and example files created");
    } catch (error) {
      log.warn(`Failed to create config directory: ${error}`);
    }
  }
}
